webpackJsonp([0],[function(t,n,e){"use strict";n.c=c,n.a=s,n.b=function(t,n){const e=c(),o=s(e,t,n),r=e.getAttribLocation(o,"a_position"),i=e.getUniformLocation(o,"u_resolution");e.useProgram(o),e.uniform2f(i,e.canvas.width,e.canvas.height);const a=[0,0,e.canvas.width,0,0,e.canvas.height,0,e.canvas.height,e.canvas.width,0,e.canvas.width,e.canvas.height],u=e.createBuffer();e.enableVertexAttribArray(r),e.bindBuffer(e.ARRAY_BUFFER,u),e.vertexAttribPointer(r,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,new Float32Array(a),e.STATIC_DRAW),e.drawArrays(e.TRIANGLES,0,a.length/2)};var o=e(2),r=e.n(o);function i(t,n,e){var o=t.createShader(n);if(t.shaderSource(o,e),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS))return o;console.warn(t.getShaderInfoLog(o)),t.deleteShader(o)}let a=null;function c(t,n){const e=document.querySelector("canvas");e&&e.remove();const o=document.querySelector(`div.${r.a.message}`);o&&o.remove();const i=document.createElement("canvas");document.querySelector("body").appendChild(i);const c=i.getContext("webgl");if(!c)throw"no webgl context";if(webglUtils.resizeCanvasToDisplaySize(c.canvas),c.viewport(0,0,c.canvas.width,c.canvas.height),c.clearColor(0,0,0,0),c.clear(c.COLOR_BUFFER_BIT),a&&(window.removeEventListener("click",a),a=null),n&&(window.addEventListener("click",n),a=n),t&&"string"==typeof t){const n=document.createElement("div");n.classList.add(r.a.message),n.innerHTML=t,document.querySelector("body").appendChild(n)}return t&&"object"==typeof t&&(t.classList.add(r.a.message),document.querySelector("body").appendChild(t)),c}function s(t,n,e){return function(t,n,e){var o=t.createProgram();if(t.attachShader(o,n),t.attachShader(o,e),t.linkProgram(o),t.getProgramParameter(o,t.LINK_STATUS))return o;console.warn(t.getProgramInfoLog(o)),t.deleteProgram(o)}(t,i(t,t.VERTEX_SHADER,n),i(t,t.FRAGMENT_SHADER,e))}},function(t,n){t.exports="  precision mediump float;\n  uniform vec2 u_resolution;\n  uniform vec3 u_color;\n\n\n  void main() {\n\n\n\n    gl_FragColor = vec4(u_color, 1.0);    \n\n  }"},function(t,n){t.exports={appSelector:"styles__appSelector__1-4UK",message:"styles__message__sERpw"}},function(t,n){t.exports="// на основе: https://github.com/mattdesl/three-line-2d/blob/master/shaders/basic.js\nprecision mediump float;\n\nuniform float u_thickness;\nuniform vec2 u_resolution;\nattribute float a_lineMiter;\nattribute vec2 a_lineNormal;\nattribute vec2 a_position;\n\nvoid main() {\n    vec2 zeroToOne = a_position / u_resolution;\n    vec2 zeroToTwo = zeroToOne * 2.0;\n    vec2 clipSpace = zeroToTwo - 1.0;  \n    clipSpace = clipSpace + vec2(\n      a_lineNormal.x * ((-u_thickness / u_resolution.x)) * a_lineMiter,\n      a_lineNormal.y * ((-u_thickness / u_resolution.y)) * a_lineMiter\n    );\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0.0, 1.0);\n}"},function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=e(2),r=e.n(o),i=e(6),a=(e.n(i),e(7));const c=t=>{window.history.pushState({num:t},t,`#${t}`),Object(a.a)(t)()},s=document.createElement("div");document.querySelector("body").appendChild(s),s.classList.add(r.a.appSelector),new Array(7).fill(null).map((t,n)=>{const e=document.createElement("button");e.innerText=n+1,s.appendChild(e)}),s.addEventListener("click",t=>{t.stopPropagation(),c(+t.target.innerText)}),window.addEventListener("popstate",t=>Object(a.a)(t.state.num)());const u=window.location.hash.replace("#","");let f=0|+u;!isNaN(f)&&u===f+""&&f>=1&&f<=7?Object(a.a)(f)():c(1)},,function(t,n){(function(){!function(t,n){"function"==typeof define&&define.amd?define([],function(){return n.call(t)}):t.webglUtils=n.call(t)}(this,function(){"use strict";const t=this;function n(n){t.console&&(t.console.error?t.console.error(n):t.console.log&&t.console.log(n))}function e(t,e,o,r){const i=r||n,a=t.createShader(o);if(t.shaderSource(a,e),t.compileShader(a),!t.getShaderParameter(a,t.COMPILE_STATUS)){return i("*** Error compiling shader '"+a+"':"+t.getShaderInfoLog(a)),t.deleteShader(a),null}return a}function o(t,e,o,r,i){const a=i||n,c=t.createProgram();if(e.forEach(function(n){t.attachShader(c,n)}),o&&o.forEach(function(n,e){t.bindAttribLocation(c,r?r[e]:e,n)}),t.linkProgram(c),!t.getProgramParameter(c,t.LINK_STATUS)){return a("Error in program linking:"+t.getProgramInfoLog(c)),t.deleteProgram(c),null}return c}function r(t,n,o,r){let i,a="";const c=document.getElementById(n);if(!c)throw"*** Error: unknown script element"+n;if(a=c.text,!o)if("x-shader/x-vertex"===c.type)i=t.VERTEX_SHADER;else if("x-shader/x-fragment"===c.type)i=t.FRAGMENT_SHADER;else if(i!==t.VERTEX_SHADER&&i!==t.FRAGMENT_SHADER)throw"*** Error: unknown shader type";return e(t,a,o||i,r)}(function(n){return(n=n||t)!==n.top})()||(console.log("%c%s","color:blue;font-weight:bold;","for more about webgl-utils.js see:"),console.log("%c%s","color:blue;font-weight:bold;","https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html"));const i=["VERTEX_SHADER","FRAGMENT_SHADER"];function a(t,n){return n===t.SAMPLER_2D?t.TEXTURE_2D:n===t.SAMPLER_CUBE?t.TEXTURE_CUBE_MAP:void 0}function c(t,n){let e=0;function o(n,o){const r=t.getUniformLocation(n,o.name),i=o.type,c=o.size>1&&"[0]"===o.name.substr(-3);if(i===t.FLOAT&&c)return function(n){t.uniform1fv(r,n)};if(i===t.FLOAT)return function(n){t.uniform1f(r,n)};if(i===t.FLOAT_VEC2)return function(n){t.uniform2fv(r,n)};if(i===t.FLOAT_VEC3)return function(n){t.uniform3fv(r,n)};if(i===t.FLOAT_VEC4)return function(n){t.uniform4fv(r,n)};if(i===t.INT&&c)return function(n){t.uniform1iv(r,n)};if(i===t.INT)return function(n){t.uniform1i(r,n)};if(i===t.INT_VEC2)return function(n){t.uniform2iv(r,n)};if(i===t.INT_VEC3)return function(n){t.uniform3iv(r,n)};if(i===t.INT_VEC4)return function(n){t.uniform4iv(r,n)};if(i===t.BOOL)return function(n){t.uniform1iv(r,n)};if(i===t.BOOL_VEC2)return function(n){t.uniform2iv(r,n)};if(i===t.BOOL_VEC3)return function(n){t.uniform3iv(r,n)};if(i===t.BOOL_VEC4)return function(n){t.uniform4iv(r,n)};if(i===t.FLOAT_MAT2)return function(n){t.uniformMatrix2fv(r,!1,n)};if(i===t.FLOAT_MAT3)return function(n){t.uniformMatrix3fv(r,!1,n)};if(i===t.FLOAT_MAT4)return function(n){t.uniformMatrix4fv(r,!1,n)};if((i===t.SAMPLER_2D||i===t.SAMPLER_CUBE)&&c){const n=[];for(let t=0;t<info.size;++t)n.push(e++);return function(n,e){return function(o){t.uniform1iv(r,e),o.forEach(function(o,r){t.activeTexture(t.TEXTURE0+e[r]),t.bindTexture(n,o)})}}(a(t,i),n)}if(i===t.SAMPLER_2D||i===t.SAMPLER_CUBE)return function(n,e){return function(o){t.uniform1i(r,e),t.activeTexture(t.TEXTURE0+e),t.bindTexture(n,o)}}(a(t,i),e++);throw"unknown type: 0x"+i.toString(16)}const r={},i=t.getProgramParameter(n,t.ACTIVE_UNIFORMS);for(let e=0;e<i;++e){const i=t.getActiveUniform(n,e);if(!i)break;let a=i.name;"[0]"===a.substr(-3)&&(a=a.substr(0,a.length-3));const c=o(n,i);r[a]=c}return r}function s(t,...n){t=t.uniformSetters||t;for(const e of n)Object.keys(e).forEach(function(n){const o=t[n];o&&o(e[n])})}function u(t,n){const e={};function o(n){return function(e){if(e.value)switch(t.disableVertexAttribArray(n),e.value.length){case 4:t.vertexAttrib4fv(n,e.value);break;case 3:t.vertexAttrib3fv(n,e.value);break;case 2:t.vertexAttrib2fv(n,e.value);break;case 1:t.vertexAttrib1fv(n,e.value);break;default:throw new Error("the length of a float constant value must be between 1 and 4!")}else t.bindBuffer(t.ARRAY_BUFFER,e.buffer),t.enableVertexAttribArray(n),t.vertexAttribPointer(n,e.numComponents||e.size,e.type||t.FLOAT,e.normalize||!1,e.stride||0,e.offset||0)}}const r=t.getProgramParameter(n,t.ACTIVE_ATTRIBUTES);for(let i=0;i<r;++i){const r=t.getActiveAttrib(n,i);if(!r)break;const a=t.getAttribLocation(n,r.name);e[r.name]=o(a)}return e}function f(t,n){t=t.attribSetters||t,Object.keys(n).forEach(function(e){const o=t[e];o&&o(n[e])})}function l(t,n,e,o){const r=t.createVertexArray();return t.bindVertexArray(r),f(n,e),o&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,o),t.bindVertexArray(null),r}function m(t,n,e){f(n,e.attribs),e.indices&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.indices)}const A=["","MOZ_","OP_","WEBKIT_"];function p(t,n,e){return function(t,n){let e=0;return t.push=function(){for(let n=0;n<arguments.length;++n){const o=arguments[n];if(o instanceof Array||o.buffer&&o.buffer instanceof ArrayBuffer)for(let n=0;n<o.length;++n)t[e++]=o[n];else t[e++]=o}},t.reset=function(t){e=t||0},t.numComponents=n,Object.defineProperty(t,"numElements",{get:function(){return this.length/this.numComponents|0}}),t}(new(e||Float32Array)(t*n),t)}function d(t,n,e,o){e=e||t.ARRAY_BUFFER;const r=t.createBuffer();return t.bindBuffer(e,r),t.bufferData(e,n,o||t.STATIC_DRAW),r}function v(t){return"indices"!==t}function _(t){return t.buffer&&t.buffer instanceof ArrayBuffer}function b(t,n){let e;if(n%(e=t.indexOf("coord")>=0?2:t.indexOf("color")>=0?4:3)>0)throw"can not guess numComponents. You should specify it.";return e}function g(t,n){if(_(t))return t;if(t.data&&_(t.data))return t.data;Array.isArray(t)&&(t={data:t}),t.numComponents||(t.numComponents=b(n,t.length));let e=t.type;e||"indices"===n&&(e=Uint16Array);const o=p(t.numComponents,t.data.length/t.numComponents|0,e);return o.push(t.data),o}function E(t,n,e){const o=e||function(t){const n={};return Object.keys(t).filter(v).forEach(function(t){n["a_"+t]=t}),n}(n),r={};return Object.keys(o).forEach(function(e){const i=o[e],a=n[i];if(a.value)r[e]={value:a.value};else{const n=g(a,i);r[e]={buffer:d(t,n),numComponents:a.numComponents||n.numComponents||b(i),type:function(t,n){if(n instanceof Int8Array)return t.BYTE;if(n instanceof Uint8Array)return t.UNSIGNED_BYTE;if(n instanceof Int16Array)return t.SHORT;if(n instanceof Uint16Array)return t.UNSIGNED_SHORT;if(n instanceof Int32Array)return t.INT;if(n instanceof Uint32Array)return t.UNSIGNED_INT;if(n instanceof Float32Array)return t.FLOAT;throw"unsupported typed array type"}(t,n),normalize:function(t){return t instanceof Int8Array||t instanceof Uint8Array}(n)}}}),r}function h(t){return t.length?t:t.data}const T=/coord|texture/i,y=/color|colour/i;function b(t,n){let e;if(n%(e=T.test(t)?2:y.test(t)?4:3)>0)throw new Error(`Can not guess numComponents for attribute '${t}'. Tried ${e} but ${n} values is not evenly divisible by ${e}. You should specify it.`);return e}const R=["position","positions","a_position"];function F(t){let n;for(const e of R)if(e in t){n=e;break}const e=t[n=n||Object.keys(t)[0]],o=h(e).length,r=function(t,n){return t.numComponents||t.size||b(n,h(t).length)}(e,n),i=o/r;if(o%r>0)throw new Error(`numComponents ${r} not correct for length ${o}`);return i}function S(t,n,e,o,r){const i=n.indices;e=void 0===e?t.TRIANGLES:e;const a=void 0===o?n.numElements:o;r=void 0===r?0:r,i?t.drawElements(e,a,t.UNSIGNED_SHORT,r):t.drawArrays(e,r,a)}return!!!document.documentMode&&!!window.StyleMedia&&(HTMLCanvasElement.prototype.getContext=function(t){return function(){let n=arguments;return"webgl"===n[0]&&((n=[].slice.call(arguments))[0]="experimental-webgl"),t.apply(this,n)}}(HTMLCanvasElement.prototype.getContext)),{createAugmentedTypedArray:p,createAttribsFromArrays:E,createBuffersFromArrays:function(t,n){const e={};return Object.keys(n).forEach(function(o){const r="indices"===o?t.ELEMENT_ARRAY_BUFFER:t.ARRAY_BUFFER,i=g(n[o],name);e[o]=d(t,i,r)}),n.indices?e.numElements=n.indices.length:n.position&&(e.numElements=n.position.length/3),e},createBufferInfoFromArrays:function(t,n,e){const o={attribs:E(t,n,e)};let r=n.indices;return r?(r=g(r,"indices"),o.indices=d(t,r,t.ELEMENT_ARRAY_BUFFER),o.numElements=r.length):o.numElements=F(n),o},createAttributeSetters:u,createProgram:o,createProgramFromScripts:function(t,n,e,a,c){const s=[];for(let e=0;e<n.length;++e)s.push(r(t,n[e],t[i[e]],c));return o(t,s,e,a,c)},createProgramFromSources:function(t,n,r,a,c){const s=[];for(let o=0;o<n.length;++o)s.push(e(t,n[o],t[i[o]],c));return o(t,s,r,a,c)},createProgramInfo:function(t,n,e,o,r){n=n.map(function(t){const n=document.getElementById(t);return n?n.text:t});const i=webglUtils.createProgramFromSources(t,n,e,o,r);return i?{program:i,uniformSetters:c(t,i),attribSetters:u(t,i)}:null},createUniformSetters:c,createVAOAndSetAttributes:l,createVAOFromBufferInfo:function(t,n,e){return l(t,n.attribSetters||n,e.attribs,e.indices)},drawBufferInfo:S,drawObjectList:function(t,n){let e=null,o=null;n.forEach(function(n){const r=n.programInfo,i=n.bufferInfo;let a=!1;r!==e&&(e=r,t.useProgram(r.program),a=!0),(a||i!==o)&&(o=i,m(t,r.attribSetters,i)),s(r.uniformSetters,n.uniforms),S(t,i)})},glEnumToString:function(t,n){const e=[];for(const o in t)t[o]===n&&e.push(o);return e.length?e.join(" | "):`0x${n.toString(16)}`},getExtensionWithKnownPrefixes:function(t,n){for(let e=0;e<A.length;++e){const o=A[e]+n,r=t.getExtension(o);if(r)return r}},resizeCanvasToDisplaySize:function(t,n){n=n||1;const e=t.clientWidth*n|0,o=t.clientHeight*n|0;return(t.width!==e||t.height!==o)&&(t.width=e,t.height=o,!0)},setAttributes:f,setBuffersAndAttributes:m,setUniforms:s}})}).call(window)},function(t,n,e){"use strict";n.a=function(t){switch(t){case 1:return o.a;case 2:return r.a;case 3:return i.a;case 4:return a.a;case 5:return c.a;case 6:return s.a;case 7:return u.a;default:return function(){throw"NO APP"}}};var o=e(8),r=e(11),i=e(14),a=e(17),c=e(29),s=e(32),u=e(35)},function(t,n,e){"use strict";var o=e(0),r=e(9),i=e.n(r),a=e(10),c=e.n(a);function s(t){return Math.floor(Math.random()*t)}function u(t,n,e,o,r,i,a,c){var s=n,u=n+o,f=e,l=e+r;t.push(s,f,i,a,c,u,f,i,a,c,s,l,i,a,c,s,l,i,a,c,u,f,i,a,c,u,l,i,a,c)}n.a=function(){const t=Object(o.c)(),n=Object(o.a)(t,i.a,c.a),e=t.getAttribLocation(n,"a_color"),r=t.getAttribLocation(n,"a_position"),a=t.getUniformLocation(n,"u_resolution");t.useProgram(n),t.uniform2f(a,t.canvas.width,t.canvas.height);const f=[];for(let t=0;t<50;t++){const t=Math.random(),n=Math.random(),e=Math.random();u(f,s(300),s(300),s(300),s(300),t,n,e)}const l=5*Float32Array.BYTES_PER_ELEMENT,m=t.createBuffer();t.enableVertexAttribArray(r),t.bindBuffer(t.ARRAY_BUFFER,m),t.vertexAttribPointer(r,2,t.FLOAT,!1,l,0),t.bufferData(t.ARRAY_BUFFER,new Float32Array(f),t.STATIC_DRAW),t.enableVertexAttribArray(e),t.vertexAttribPointer(e,3,t.FLOAT,!1,l,2*Float32Array.BYTES_PER_ELEMENT),t.bindBuffer(t.ARRAY_BUFFER,m),t.drawArrays(t.TRIANGLES,0,300)}},function(t,n){t.exports="  precision mediump float;\n  attribute vec3 a_color;\n  attribute vec2 a_position;\n  varying vec3 theColor;\n  uniform vec2 u_resolution;\n\n  void main() {\n\n    vec2 zeroToOne = a_position / u_resolution;\n    vec2 zeroToTwo = zeroToOne * 2.0;\n    vec2 clipSpace = zeroToTwo - 1.0;\n    theColor = a_color;\n\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0.0, 1.0);\n  }"},function(t,n){t.exports="  precision mediump float;\n  uniform vec2 u_resolution;\n  varying vec3 theColor;\n\n  void main() {\n    gl_FragColor = vec4(theColor, 1.0);\n  }"},function(t,n,e){"use strict";var o=e(0),r=e(12),i=e.n(r),a=e(13),c=e.n(a);n.a=function(){Object(o.b)(i.a,c.a)}},function(t,n){t.exports="  precision mediump float;\n  \n  attribute vec2 a_position;\n  uniform vec2 u_resolution;\n\n  void main() {\n\n    vec2 zeroToOne = a_position / u_resolution;\n    vec2 zeroToTwo = zeroToOne * 2.0;\n    vec2 clipSpace = zeroToTwo - 1.0;\n  \n    gl_Position = vec4(clipSpace * vec2(1, -1), 0.0, 1.0);\n  }"},function(t,n){t.exports="  precision mediump float;\n  uniform vec2 u_resolution;\n\n/* \n  float plot(vec2 st) {    \n      //return 1.0 - step(0.0025, abs(st.y - st.x));\n      return smoothstep(0.005, 0.0, abs(st.y - st.x));\n      \n  }\n\n  float plot2(vec2 st, float pct){\n  return  smoothstep( pct-0.005, pct, st.y) -\n          smoothstep( pct, pct+0.005, st.y);\n  return  step( pct, st.y) ;\n}\n */\n\n  void main() {\n\n    vec2 st = (2.0 * gl_FragCoord.xy/u_resolution) - 1.0;\n    \n    /*  \n      float pct = plot(st);\n      vec3 color = vec3(pct);\n\t    gl_FragColor = vec4(color,1.0)*vec4(0,1,0,1);    \n     */\n\n/*     float y = pow(st.x,0.5);\n    float pct = plot2(st,y);\n    vec3 color = pct*vec3(0.0,1.0,0.0); */\n\n\n    // gl_FragColor = vec4(color,1.0)*vec4(0,1,0,1);    \n\n    float c =  \n        smoothstep(0.49, 0.5, sqrt(st.x * st.x + st.y * st.y))\n       - smoothstep(0.7, 0.71, sqrt(st.x * st.x + st.y * st.y));\n\n/*      c =  \n        step(0.5, sqrt(st.x * st.x + st.y * st.y))\n       - step(0.51, sqrt(st.x * st.x + st.y * st.y));        */\n\n    gl_FragColor = vec4(0,c,0,1);\n    \n    /* gl_FragColor = vec4(0, \n      smoothstep(0.005, 0.0, st.x)\n      ,0,1);     */\n\n\n  }"},function(t,n,e){"use strict";var o=e(0),r=e(15),i=e.n(r),a=e(16),c=e.n(a);n.a=function(){Object(o.b)(i.a,c.a)}},function(t,n){t.exports="  precision mediump float;\n  \n  attribute vec2 a_position;\n  uniform vec2 u_resolution;\n\n  void main() {\n\n    vec2 zeroToOne = a_position / u_resolution;\n    vec2 zeroToTwo = zeroToOne * 2.0;\n    vec2 clipSpace = zeroToTwo - 1.0;\n  \n    gl_Position = vec4(clipSpace * vec2(1, -1), 0.0, 1.0);\n  }"},function(t,n){t.exports="  precision mediump float;\n  uniform vec2 u_resolution;\n\n\n  float plot2(vec2 st, float yValue){\n  return  smoothstep( yValue-0.005, yValue, st.y) -\n          0.9 * smoothstep( yValue, yValue+0.005, st.y);\n}\n\n\n  void main() {\n\n    vec2 st = (2.0 * gl_FragCoord.xy/u_resolution) - 1.0;\n\n    float yValue = -3.0 * pow(st.x,2.0);\n    float v = plot2(st,yValue);\n    vec3 color = v*vec3(0.0, 1.0, 0.0);\n\n    gl_FragColor = vec4(color, 1.0);    \n\n  }"},function(t,n,e){"use strict";n.a=function t(){const n=Object(o.c)("Click to redraw",t);let e;void 0;if(!e){const t=5,n=[];Array(t+1).fill(null).map(()=>n.push([s(700),s(700)]));const o=s(50,10);e={path:n,thickness:o},console.log(JSON.stringify(e))}e.normals=i()(e.path,!1);Object(c.a)(n,e);Object(a.a)(n,e)};var o=e(0),r=e(18),i=e.n(r),a=(e(25),e(26)),c=e(28);const s=(t,n)=>{let e=Math.floor(Math.random()*t);return n&&e<n?n:e}},,,,,,,,function(t,n,e){"use strict";e(0);var o=e(3),r=(e.n(o),e(1));e.n(r)},function(t,n,e){"use strict";n.a=function(t,{path:n}){const e=Object(o.a)(t,i.a,c.a),r=t.getAttribLocation(e,"a_position"),a=t.getUniformLocation(e,"u_resolution"),s=t.getUniformLocation(e,"u_color");t.useProgram(e),t.uniform2f(a,t.canvas.width,t.canvas.height),t.uniform3f(s,1,1,1);const u=n.flat(),f=t.createBuffer();t.enableVertexAttribArray(r),t.bindBuffer(t.ARRAY_BUFFER,f),t.vertexAttribPointer(r,2,t.FLOAT,!1,0,0),t.bufferData(t.ARRAY_BUFFER,new Float32Array(u),t.STATIC_DRAW),t.drawArrays(t.LINE_STRIP,0,u.length/2)};var o=e(0),r=e(27),i=e.n(r),a=e(1),c=e.n(a)},function(t,n){t.exports="  precision mediump float;\n  \n  attribute vec2 a_position;\n  uniform vec2 u_resolution;\n\n  void main() {\n\n    vec2 zeroToOne = a_position / u_resolution;\n    vec2 zeroToTwo = zeroToOne * 2.0;\n    vec2 clipSpace = zeroToTwo - 1.0;\n  \n    gl_Position = vec4(clipSpace * vec2(1, -1), 0.0, 1.0);\n  }"},function(t,n,e){"use strict";n.a=function(t,{path:n,normals:e,thickness:r}){const a=Object(o.a)(t,i.a,c.a),s=t.getAttribLocation(a,"a_position"),u=t.getAttribLocation(a,"a_lineNormal"),f=t.getAttribLocation(a,"a_lineMiter"),l=t.getUniformLocation(a,"u_resolution"),m=t.getUniformLocation(a,"u_color"),A=t.getUniformLocation(a,"u_thickness");t.useProgram(a),t.uniform2f(l,t.canvas.width,t.canvas.height),t.uniform3f(m,.4,.4,.6),t.uniform1f(A,r);const p=5*Float32Array.BYTES_PER_ELEMENT,d=t.createBuffer();t.enableVertexAttribArray(s),t.bindBuffer(t.ARRAY_BUFFER,d),t.vertexAttribPointer(s,2,t.FLOAT,!1,p,0),t.enableVertexAttribArray(u),t.bindBuffer(t.ARRAY_BUFFER,d),t.vertexAttribPointer(u,2,t.FLOAT,!1,p,2*Float32Array.BYTES_PER_ELEMENT),t.enableVertexAttribArray(f),t.bindBuffer(t.ARRAY_BUFFER,d),t.vertexAttribPointer(f,1,t.FLOAT,!1,p,4*Float32Array.BYTES_PER_ELEMENT);const v=[];for(let t=0,o=n.length;t<o-1;t++)v.push(...n[t],...e[t][0],e[t][1],...n[t],...e[t][0],-e[t][1],...n[t+1],...e[t+1][0],e[t+1][1],...n[t],...e[t][0],-e[t][1],...n[t+1],...e[t+1][0],e[t+1][1],...n[t+1],...e[t+1][0],-e[t+1][1]);t.bufferData(t.ARRAY_BUFFER,new Float32Array(v),t.STATIC_DRAW),t.drawArrays(t.TRIANGLES,0,6*(n.length-1))};var o=e(0),r=e(3),i=e.n(r),a=e(1),c=e.n(a)},function(t,n,e){"use strict";var o=e(0),r=e(30),i=e.n(r),a=e(31),c=e.n(a);n.a=function(){const t=Object(o.c)(),n=Object(o.a)(t,i.a,c.a),e=t.getAttribLocation(n,"a_color"),r=t.getAttribLocation(n,"a_position"),a=t.getUniformLocation(n,"u_resolution"),s=t.getUniformLocation(n,"u_rotationAngle");t.useProgram(n),t.uniform2f(a,t.canvas.width,t.canvas.height);const u=5*Float32Array.BYTES_PER_ELEMENT,f=t.createBuffer();t.enableVertexAttribArray(r),t.bindBuffer(t.ARRAY_BUFFER,f),t.vertexAttribPointer(r,2,t.FLOAT,!1,u,0),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,0,150,0,1,0,250,0,0,0,1]),t.STATIC_DRAW),t.enableVertexAttribArray(e),t.vertexAttribPointer(e,3,t.FLOAT,!1,u,2*Float32Array.BYTES_PER_ELEMENT),t.bindBuffer(t.ARRAY_BUFFER,f);let l=0;const m=()=>{l=l<360?l+1:0,t.uniform1f(s,l),t.drawArrays(t.TRIANGLES,0,3),requestAnimationFrame(m)};m()}},function(t,n){t.exports="precision mediump float;\nattribute vec3 a_color;\nattribute vec2 a_position;\nvarying vec3 theColor;\nuniform vec2 u_resolution;\nuniform float u_rotationAngle;\n\n// NOTE: допустимо ли осуществлять вычисления вне main? \n// NOTE: будут ли они выполнены только при инициализации или на каждой итерации? является ли оптимизацией? или выносить вообще в js?\nfloat a = (u_rotationAngle / 180.0) * 3.1415926;\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, s, -s, c);\n\nvoid main() {\n\n  theColor = a_color;\n\n  vec2 rotatedPosition = a_position * m;\n\n  vec2 clipSpace = (rotatedPosition / u_resolution) * 2.0;\n\n  gl_Position = vec4(clipSpace, 0.0, 1.0);\n\n}"},function(t,n){t.exports="precision mediump float;\nuniform vec2 u_resolution;\nvarying vec3 theColor;\n\nvoid main() {\n  gl_FragColor = vec4(theColor, 1.0);\n}"},function(t,n,e){"use strict";var o=e(0),r=e(33),i=e.n(r),a=e(34),c=e.n(a);n.a=function(){const t=Object(o.c)(),n=Object(o.a)(t,i.a,c.a),e=t.getAttribLocation(n,"a_color"),r=t.getAttribLocation(n,"a_position"),a=t.getUniformLocation(n,"u_resolution"),s=t.getUniformLocation(n,"u_rotationAngle");t.useProgram(n),t.uniform2f(a,t.canvas.width,t.canvas.height);const u=[0,0,1,0,0,0,100,0,1,0,100,0,0,0,1,100,100,1,0,0,0,100,0,1,0,100,0,0,0,1],f=5*Float32Array.BYTES_PER_ELEMENT,l=t.createBuffer();t.enableVertexAttribArray(r),t.bindBuffer(t.ARRAY_BUFFER,l),t.vertexAttribPointer(r,2,t.FLOAT,!1,f,0),t.bufferData(t.ARRAY_BUFFER,new Float32Array(u),t.STATIC_DRAW),t.enableVertexAttribArray(e),t.vertexAttribPointer(e,3,t.FLOAT,!1,f,2*Float32Array.BYTES_PER_ELEMENT),t.bindBuffer(t.ARRAY_BUFFER,l);let m=0;const A=()=>{m=m<360?m+1:0,t.uniform1f(s,m),t.drawArrays(t.TRIANGLES,0,u.length/5),requestAnimationFrame(A)};A()}},function(t,n){t.exports="precision mediump float;\nattribute vec3 a_color;\nattribute vec2 a_position;\nvarying vec3 theColor;\nuniform vec2 u_resolution;\nuniform float u_rotationAngle;\n\n// NOTE: допустимо ли осуществлять вычисления вне main? \n// NOTE: будут ли они выполнены только при инициализации или на каждой итерации? является ли оптимизацией? или выносить вообще в js?\nfloat a = (u_rotationAngle / 180.0) * 3.1415926;\nfloat s = sin(a);\nfloat c = cos(a);\nmat2 m = mat2(c, s, -s, c);\n\nvec2 translation = vec2(100.0, 100.0);\n\nvoid main() {\n\n  theColor = a_color;\n\n  vec2 rotatedPosition = (a_position + translation)* m;\n\n  vec2 clipSpace = (rotatedPosition / u_resolution) * 2.0;\n\n  gl_Position = vec4(clipSpace, 0.0, 1.0);\n\n}"},function(t,n){t.exports="precision mediump float;\nuniform vec2 u_resolution;\nvarying vec3 theColor;\n\nvoid main() {\n  gl_FragColor = vec4(theColor, 1.0);\n}"},function(t,n,e){"use strict";var o=e(0),r=e(36),i=e.n(r),a=e(37),c=e.n(a),s=e(38);n.a=function(){let t=!1,n=!1,e=0,r=0,a=0;const u=document.createElement("div");u.style.position="absolute",u.style.zIndex="20",u.style.display="flex",u.style.gap="10px";const f=Object(s.a)("set rotated");f.addEventListener("click",n=>{n.stopPropagation(),(n=>t=n)(!t),f.innerText=t?"unset rotated":" set rotated "}),u.appendChild(f);const l=Object(s.a)("set titled");l.addEventListener("click",t=>{t.stopPropagation(),(t=>n=t)(!n),l.innerText=n?"unset tilted":" set tilted "}),u.appendChild(l);const m=Object(o.c)(u),A=Object(o.a)(m,i.a,c.a),p=m.getAttribLocation(A,"a_color"),d=m.getAttribLocation(A,"a_position"),v=m.getUniformLocation(A,"u_transform");m.useProgram(A);const _=[];for(let t=0;t<50;t++){const t=Math.random(),n=Math.random(),e=Math.random();Object(s.d)(_,Object(s.c)(300),Object(s.c)(300),Object(s.c)(300),Object(s.c)(300),t,n,e)}const b=5*Float32Array.BYTES_PER_ELEMENT,g=m.createBuffer();m.bindBuffer(m.ARRAY_BUFFER,g),m.bufferData(m.ARRAY_BUFFER,new Float32Array(_),m.STATIC_DRAW),m.enableVertexAttribArray(d),m.vertexAttribPointer(d,2,m.FLOAT,!1,b,0),m.enableVertexAttribArray(p),m.vertexAttribPointer(p,3,m.FLOAT,!1,b,2*Float32Array.BYTES_PER_ELEMENT);const E=o=>{if(!0!==o&&Date.now()-a<15)return void requestAnimationFrame(E);a=Date.now();let i=!1;if(t&&e<45&&((e+=3)>45&&(e=45),i=!0),!t&&e>0&&((e-=3)<0&&(e=0),i=!0),n&&r<45&&((r+=3)>45&&(r=45),i=!0),!n&&r>0&&((r-=3)<0&&(r=0),i=!0),i||!0===o){const t=e/180*3.1415926,n=Math.sin(t),o=Math.cos(t),i=r/180*3.1415926,a=Math.sin(i),c=Math.cos(i),u=[o,-n,0,0,n,o,0,0,0,0,1,0,0,0,0,1],f=[1,0,0,0,0,c,a,0,0,-a,c,0,0,0,0,1],l=1e3,A=[2/m.canvas.width,0,0,0,0,2/m.canvas.height,0,0,0,0,2/l,0,0,0,0,1],p=s.b.multiply(A,s.b.multiply(f,u));m.uniformMatrix4fv(v,!1,p),m.drawArrays(m.TRIANGLES,0,_.length/5)}requestAnimationFrame(E)};E(!0)}},function(t,n){t.exports="precision mediump float;\nattribute vec3 a_color;\nattribute vec2 a_position;\nvarying vec3 theColor;\nuniform mat4 u_transform;\n\nvoid main() {\n\n  theColor = a_color;\n\n  vec4 transformedPosition = u_transform * vec4(a_position.xy, 0.0, 1.0);\n\n  float zToDivideBy = 1.0 + transformedPosition.z * 0.25;\n\n  gl_Position = vec4(transformedPosition.xy / zToDivideBy, transformedPosition.zw);\n\n}"},function(t,n){t.exports="precision mediump float;\nuniform vec2 u_resolution;\nvarying vec3 theColor;\n\nvoid main() {\n  gl_FragColor = vec4(theColor, 1.0);\n}"},function(t,n,e){"use strict";n.c=function(t){return Math.floor(Math.random()*t-t/2)},n.d=function(t,n,e,o,r,i,a,c){const s=n,u=n+o,f=e,l=e+r;t.push(s,f,i,a,c,u,f,i,a,c,s,l,i,a,c,s,l,i,a,c,u,f,i,a,c,u,l,i,a,c)};n.b={multiply:function(t,n){const e=n[0],o=n[1],r=n[2],i=n[3],a=n[4],c=n[5],s=n[6],u=n[7],f=n[8],l=n[9],m=n[10],A=n[11],p=n[12],d=n[13],v=n[14],_=n[15],b=t[0],g=t[1],E=t[2],h=t[3],T=t[4],y=t[5],R=t[6],F=t[7],S=t[8],x=t[9],L=t[10],w=t[11],O=t[12],P=t[13],B=t[14],C=t[15];return[e*b+o*T+r*S+i*O,e*g+o*y+r*x+i*P,e*E+o*R+r*L+i*B,e*h+o*F+r*w+i*C,a*b+c*T+s*S+u*O,a*g+c*y+s*x+u*P,a*E+c*R+s*L+u*B,a*h+c*F+s*w+u*C,f*b+l*T+m*S+A*O,f*g+l*y+m*x+A*P,f*E+l*R+m*L+A*B,f*h+l*F+m*w+A*C,p*b+d*T+v*S+_*O,p*g+d*y+v*x+_*P,p*E+d*R+v*L+_*B,p*h+d*F+v*w+_*C]}};n.a=(t=>{const n=document.createElement("button");return n.innerText=t,n.style.padding="20px",n.style.whiteSpace="pre-wrap",n.style.fontFamily="monospace",n})}],[4]);